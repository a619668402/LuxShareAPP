1.Configuration
2.ViewConfiguration
3.GestureDetetor
4.VelocityTracker
5.Scroller
6.ViewDragHelper


1.Configuration 用来描述设备的配置信息
比如:
	用户的配置信息:locale和scaling等等
	设备的相关信息:输入模式,屏幕大小,屏幕方向
// 获取实例对象
Configuration configuration = getResources().getConfiguration();


2.ViewConfiguration 提供一些自定义控件用到的标准常量
比如:
	尺寸大小,滑动距离,敏感度等
// 获取实例对象
ViewConfiguration configuration = ViewConfiguration.get(context);


3.GestureDetector 手势监听类
给控件添加手势步骤
(1).实现OnGestureListener
private class GestureListenerImpl implements GestureDetector.OnGestureListener {

        // 触摸屏幕的时候触发
        @Override
        public boolean onDown(MotionEvent motionEvent) {
            Log.i(TAG, "onDown: ");
            return false;
        }

        // 手指在屏幕上按下,且未移动和松开的时候调用该方法
        @Override
        public void onShowPress(MotionEvent motionEvent) {
            Log.i(TAG, "onShowPress: ");
        }

        // 轻击屏幕的时候调用该方法
        @Override
        public boolean onSingleTapUp(MotionEvent motionEvent) {
            Log.i(TAG, "onSingleTapUp: ");
            return false;
        }

        // 手指在屏幕上滚动的时候回调用该方法
        @Override
        public boolean onScroll(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) {
            Log.i(TAG, "onScroll: ");
            return false;
        }

        // 手指长按屏幕时均会调用该方法
        @Override
        public void onLongPress(MotionEvent motionEvent) {
            Log.i(TAG, "onLongPress: ");
        }

        // 手指在屏幕上拖动的时候调用
        @Override
        public boolean onFling(MotionEvent motionEvent, MotionEvent motionEvent1, float v, float v1) {
            Log.i(TAG, "onFling: ");
            return false;
        }
    }

(2).生成GestureDetector对象
GestureDetector mGestureDetector = new GestureDetector(this, new GestureListenerImpl());

(3).将Touch事件交给GestureDetector处理
比如:
将Activity的Touch事件交给GestureDetector处理
 @Override
 public boolean onTouchEvent(MotionEvent event) {
    return mGestureDetector.onTouchEvent(event);
 }

将View的Touch事件交给GestureDetector处理
Button button = (Button) findViewById(R.id.btn);
button.setOnTouchLinstener(new onTouchListener() {
 @Override
 Public boolean onTouch(View view,MotionEvent event) {
	return mGestureDetector.onTouchEvent(event);
 }
}


4.VelocityTracker 速度追踪,用于跟踪触摸屏事件(比如:Flinging及其他Gestures手势事件等)速率
	@Override
    public boolean onTouchEvent(MotionEvent event) {
        switch (event.getAction()) {
            case MotionEvent.ACTION_DOWN:
                if (mTracker == null) {
                    mTracker = VelocityTracker.obtain();
                }
                mTracker.addMovement(event);
                break;
            case MotionEvent.ACTION_MOVE:
                mTracker.addMovement(event);
                mTracker.computeCurrentVelocity(1000);
                Log.i(TAG, "onTouchEventX: " + mTracker.getXVelocity());
                Log.i(TAG, "onTouchEventY: " + mTracker.getYVelocity());
                break;
            case MotionEvent.ACTION_UP:
            case MotionEvent.ACTION_CANCEL:
                mTracker.recycle();
                mTracker = null;// 必须要置空,否则报错
                break;
        }
        return super.onTouchEvent(event);
    }


5.Scroller
(1).scrollBy源码:
public void scrollBy(int x,int y) {
	scrollTo(mScrollX + x,mScrollY + y);
}
scrollBy()调用了scrollTo(),最终起作用的是scrollTo的方法.

(2).scroll的本质
scrollTo()和scrollBy()移动的只是View的内容,而且View的背景是不移动的.

(3).scrollTo和scrollBy的坐标说明
对于一个TextView调用scrollTo(0,4),文字是向上移动.
因为该方法最终会导致视图重绘,即会调用
public void invalidate(int l,int t,int r,int b);此处的l,t,r,b四个参数表示View原来的坐标
在该方法中最终会调用
tmpr.set(l - scrollX,t - scrollY,r - scrollX,b - scrollY);
p.invalidateChild(this,tmpr);

其中tmpr是一个Rect,this是原来的View;通过这两行代码就把View在一个Rect中重绘.
原来的l和r均减去了scrollX,原来的t和b均减去了scrollY;
就是说scrollX如果是正值,那么重绘之后的View的宽度反而减少,反之同理
就是说scrollY如果是正值,那么重绘之后的View的高度反而减少,反之同理













